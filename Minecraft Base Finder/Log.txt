
This is a program meant to be used to find areas in Minecraft worlds which have a high chance of having a base.

It reads .mca files and gives a probability for each chunk to contain a base.
This is calculated by finding the relative proportions of 3 types of blocks: Natural, Possibly manmade, and Certainly manmade

Examples of each type of block, respectively, are: Grass (naturally generated), Stone Bricks (generated in strongholds), and Jukeboxes (can only be placed by players).
(Note: maybe there should be another type between possibly and certainly, for things like colored wool and others)

For now, this program will only be made to support version 1.12.2 of Minecraft.



Steps to completion:
1. Find a way to read the data in .mca files
	a. Read binary data
-   - Success, just used fstream and .read() to read all 8192 bytes of the header
-	- EDIT: GENERALLY USING FSTREAM WORKS, NOT JUST .read()

2. Interpret the data in the header
- Each region (.mca) file contains data for 32x32 (1024) chunks.
- Each chunk has a location offset and timestamp in 2 tables which make up the header.
- Each of these is 4 bytes 
-   - first 3 bytes hold a big-endian offset in 4 kibibyte sections from start of file
-   - last byte gives length of chunk in 4 KiB sectors, rounded up.
-	- If chunk isn't present/not generated, both fields are 0.
	a. Output offset data in more readable format
-	- Finally done, took a while because data was being read into header array as zeros, likely as a result of not opening the file in binary mode.
-	- Also, I was getting errors when deallocating because I was writing out of bounds.

3. Access and read the chunk data
	a. Figure out how to decompress the data and read in NBT format
-	- Chunk data uses zlib compression
-	- Compressed chunk data is now in a vector
-	- this zlib stuff is so annoying, but i think i found a way forward - use realloc() in a loop. i'll leave that for later
-	- Note: I'm almost definitely allocating more memory than needed for chunk data, but there's probably no need to trim it down since it'll be deallocated anyway.
-	-	- Also, I need to update this log
-	- The zlib library is now (12/24/24) correctly transferrable over github, had to change .gitignore and some linker configurations

4. Clean up and restructure code (1/8/25)
	a. Add comments where it helps
-	- Added comments to functions and other places to decrease the time it takes to understand what's going on.
	b. Restructure code to support more than one region file
-	- Up until now things were written only to make the main functionality, this was done in a way that only 1 chunk of 1 region file was used.
-	- I'll make a class for region files, test again with just 1 chunk, then try all chunks and then all region files.
-	-	- (1/9/25) Progress with the class is good, header and compressed chunk functionality is done. Next will be testing output to a txt file for just 1 and then 1024 chunks.
-	-	- (1/11/25) Output was tested and works. Next is chunk data decompression and finally reading the NBT data. Also fixed external library stuff and added libnbt to the project.



12/22/25

Major changes added since last log update:
- Bare-minimum functionality (scans test region file and displays heatmap) (March 2025)
- Converted to CMake project for simpler dependency management (Sept-Oct 2025)

The next steps/goals are as follows:

- Refactor Region.h
	- Split into header and implementation files - DONE
	- Optimize array resizing by allocating sufficient memory at the beginning - DONE
	- Rewrite readChunk to not read 1 byte at a time (avoid extra overhead) - DONE
	- Fix hard-coded block list in constructors (use bitset) - DONE
		- Implement using external file for block filters - DONE
		- Change to bitset - DONE
	- Fix other stuff that could probably be done better
		- Replace some dynamic arrays and vectors with structs for better clarity (like for chunk info) - DONE
			- Done for chunkInfo, all others
		- Replace dynamic arrays with vectors where possible - AFAIK DONE
		- Optimize readNBT - DONE
		- Optimize chunkScore - DONE
			- Fix incorrect logic for reading nibbles (4-bit) - DONE
	- Clean up old commented out code - Mostly DONE

- Make functional for more than the test region

- Switch to zlib-ng eventually, not top priority

- 

Optimizations to test:
- 4-byte ChunkLocation struct

Other things to do/try:
- Update CMakePresets.json to be like what's in CMakeUserPresets.json for possibly better portability



12/29/25

Above topics will be revisited later
Next step:

- Implement BlockFilter class
	- Goals:
		- Separate the the targetBlocks map and bitsets from Region to avoid repeated initialization for each new Region instance - DONE
		- Support sharing the filter across multiple instances of Region - DONE
		- Initialize filter from external JSON file - DONE
			- went with custom format instead of JSON
		- (Future) Support user configuration and saving to file



1/3/26

Implemented BlockFilter
Fixed bug in chunkScore - was checking if Blocks and Data arrays exist after trying to access them, moved check before access

Further optimizations for Region:
- Split NBT parsing into separate class
- Instead of doing one step for every chunk at a time, do every step for one chunk at a time. (don't need to store all chunk data, just data for the one chunk.)
  (May also help with CPU performance - cache locality benefits)
- See where smart pointers can be used (BaseFinderView.cpp, use shared for BlockFilter, unique for Region)
- Implement actual error handling, bounds checking, etc

Besides that, it looks like working on the UI again is next.



1/11/26

Now focusing on UI. This is the plan so far:

- Scan all region files of a world (single threaded for now) - DONE
	Instead of making a huge QImage based on the boundaries of the world, which will waste memory,
	a QImage tile can be made for each region, then added to the QGraphicsView. - DONE

and before that,
- Add world folder selection - DONE
	- Display # of region files in folder - DONE

Also some things I'd like to do with Region.h:
- Improve/add comments
- Unit tests



1/15/26

Made significant progress, detailed below
- Implemented multithreading with QThreadPool (which automatically creates and manages as many threads as a system can support)
  GUI runs on the main thread, with region scans running on threads in the pool
  Made task class for QThreadPool, defined in RegionTask.h
- Added region folder selection in UI
- Added start button disable during scan
- Added map panning (dragging)
- Added chunk/block coords indicator based on position of mouse over map
- And added a bunch of signals/slots/connections to make it all work

As an observation, it feels like development with Qt is much faster than I expected now that I know it well enough.

To do next:
- Add to/fix filter (doesn't cover all significant blocks)
- Implement pause button functionality (be mindful of threads)
- Add progress bar? or number of regions scanned out of all
- Revisit scoring logic
- Set default directory for region folder selection to the saves folder in default location of minecraft
  (Will need to adjust for non-windows platforms)
- Make coords indicator cleaner, maybe add padding around text
- Change default background color for map to something more comfortable/less bright (gray?)
- Change setting of sceneRect from hard-coded values to 3-5x most distant coord from center
- Change order of regions in the set to be sorted by sum of absolute value of coords (or dist of coords w/ pythag. theor?)

But before that,
- Add error handling, comments